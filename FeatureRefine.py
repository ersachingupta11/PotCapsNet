# -*- coding: utf-8 -*-
"""Untitled15.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1aFYwed-wT4MZREfjkZ5C9mYMQ-bIIZrg
"""

class ShuffleBlock(nn.Module):
    def __init__(self, dim, num_groups):
        super().__init__()
        self.num_groups = num_groups
        self.conv = nn.Conv1d(dim, dim, kernel_size=3, stride=1, padding=1, groups=num_groups, bias=False)
        self.bn = nn.BatchNorm1d(dim)

    def forward(self, x):
        batch_size, sequence_length, hidden_size = x.size()
        assert hidden_size % self.num_groups == 0, f"hidden_size ({hidden_size}) must be divisible by num_groups ({self.num_groups})"

        x = x.view(batch_size, sequence_length, self.num_groups, hidden_size // self.num_groups)

        x = x.permute(0, 1, 3, 2).contiguous()

        x = x.view(-1, self.num_groups)

        x = self.bn(self.conv(x))

        x = x.view(batch_size, sequence_length, hidden_size)

        x = x.permute(0, 2, 1).contiguous()

        return x

class SpatialGate(nn.Module):
    def __init__(self, hidden_dim, num_groups):
        super(SpatialGate, self).__init__()
        kernel_size = 7
        self.compress = ChannelPool()
        self.shuffle = ShuffleBlock(hidden_dim, num_groups)
        self.spatial = BasicConv(2, 1, kernel_size, stride=1, padding=(kernel_size-1) // 2, relu=False)

    def forward(self, x):
        x_compress = self.compress(x)
        x_shuffle = self.shuffle(x_compress)
        x_out = self.spatial(x_shuffle)
        scale = F.sigmoid(x_out) # broadcasting
        return x * scale

class CBAM(nn.Module):
    def __init__(self, gate_channels, reduction_ratio=16, pool_types=['avg', 'max'], no_spatial=False):
        super(CBAM, self).__init__()
        self.ChannelGate = ChannelGate(gate_channels, reduction_ratio, pool_types)
        self.no_spatial=no_spatial
        if not no_spatial:
            self.SpatialGate = SpatialGate(hidden_dim=256, num_groups=8)
    def forward(self, x):
        x_out = self.ChannelGate(x)
        if not self.no_spatial:
            x_out = self.SpatialGate(x_out)
        return x_out

